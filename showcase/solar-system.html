<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>3D Solar System with Kepler Orbits</title>
  <style>
    body { 
      margin: 0; 
      overflow: hidden;
      font-family: Arial, sans-serif;
    }
    canvas { 
      display: block; 
    }
    .controls {
      position: absolute;
      top: 10px;
      left: 10px;
      z-index: 100;
    }
    .control-btn {
      background: rgba(255, 255, 255, 0.7);
      border: none;
      padding: 8px 12px;
      margin: 5px;
      font-size: 14px;
      cursor: pointer;
      border-radius: 4px;
      transition: background 0.3s ease;
    }
    .control-btn:hover {
      background: rgba(255, 255, 255, 0.9);
    }
    .info-panel {
      position: absolute;
      bottom: 20px;
      right: 20px;
      background: rgba(0, 0, 0, 0.7);
      color: white;
      padding: 15px;
      border-radius: 8px;
      max-width: 300px;
      z-index: 100;
      display: none;
      transition: opacity 0.3s ease;
    }
    .planet-label {
      color: white;
      font-size: 12px;
      padding: 3px 6px;
      background: rgba(0, 0, 0, 0.5);
      border-radius: 4px;
      text-align: center;
      user-select: none;
      pointer-events: none;
    }
    .loading {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: black;
      color: white;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      transition: opacity 1s ease;
    }
  </style>
  <!-- Import map to resolve bare module specifiers -->
  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.152.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.152.0/examples/jsm/"
    }
  }
  </script>
  <script src="../js/showcase-nav.js"></script>
</head>
<body>
  <div class="loading">Loading Solar System...</div>

  <div class="controls">
    <button id="toggleOrbits" class="control-btn">Toggle Orbits</button>
    <button id="toggleLabels" class="control-btn">Toggle Labels</button>
    <button id="resetCamera" class="control-btn">Reset View</button>
    <button id="toggleUFO" class="control-btn">Toggle UFO</button>
  </div>

  <div id="infoPanel" class="info-panel">
    <h3 id="planetName">Planet</h3>
    <p id="planetInfo">Information about the planet will appear here.</p>
  </div>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { CSS2DRenderer, CSS2DObject } from 'three/addons/renderers/CSS2DRenderer.js';

    // Main application class
    class SolarSystem {
      constructor() {
        this.initScene();
        this.initLights();
        this.initControls();
        this.loadTextures().then(() => {
          this.createSun();
          this.createPlanets();
          this.createAsteroidBelt();
          this.createUFO();
          this.createStarfield();
          this.setupEventListeners();
          this.hideLoading();
          this.animate();
        });
      }

      initScene() {
        // Setup scene
        this.scene = new THREE.Scene();
        this.camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 2000);
        this.camera.position.set(0, 50, 100);

        // Setup renderers
        this.renderer = new THREE.WebGLRenderer({ 
          antialias: true,
          powerPreference: "high-performance"
        });
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.body.appendChild(this.renderer.domElement);

        // Setup CSS2D renderer for labels
        this.labelRenderer = new CSS2DRenderer();
        this.labelRenderer.setSize(window.innerWidth, window.innerHeight);
        this.labelRenderer.domElement.style.position = 'absolute';
        this.labelRenderer.domElement.style.top = '0px';
        this.labelRenderer.domElement.style.pointerEvents = 'none';
        document.body.appendChild(this.labelRenderer.domElement);

        // Clock for animations
        this.clock = new THREE.Clock();

        // Storage
        this.planets = [];
        this.orbitLines = [];
        this.labels = [];
        this.asteroids = [];
        this.planetMeshes = new Map(); // Map planet names to meshes
      }

      initLights() {
        // Ambient light
        this.ambientLight = new THREE.AmbientLight(0x333333);
        this.scene.add(this.ambientLight);

        // Point light (sun)
        this.sunLight = new THREE.PointLight(0xffffff, 2, 300);
        this.scene.add(this.sunLight);
      }

      initControls() {
        this.controls = new OrbitControls(this.camera, this.renderer.domElement);
        this.controls.enableDamping = true;
        this.controls.dampingFactor = 0.05;
        this.controls.minDistance = 10;
        this.controls.maxDistance = 500; // Increase max distance to see the stars
        this.controls.update();
      }

      async loadTextures() {
        // Initialize textures object
        this.textures = {};
        
        // Create procedural textures for all planets except Earth (which will load from URL)
        
        // Sun - yellow-orange gradient with surface details
        const sunCanvas = document.createElement('canvas');
        sunCanvas.width = 512;
        sunCanvas.height = 512;
        const sunCtx = sunCanvas.getContext('2d');
        const sunGrad = sunCtx.createRadialGradient(256, 256, 0, 256, 256, 256);
        sunGrad.addColorStop(0, '#ffff80');
        sunGrad.addColorStop(0.5, '#ffdd00');
        sunGrad.addColorStop(1, '#ff8800');
        sunCtx.fillStyle = sunGrad;
        sunCtx.fillRect(0, 0, 512, 512);
        // Add solar granulation
        for (let i = 0; i < 1000; i++) {
          const x = Math.random() * 512;
          const y = Math.random() * 512;
          const r = Math.random() * 8 + 4;
          sunCtx.beginPath();
          sunCtx.arc(x, y, r, 0, Math.PI * 2);
          sunCtx.fillStyle = `rgba(255, 200, 0, ${Math.random() * 0.3})`;
          sunCtx.fill();
        }
        this.textures.sun = new THREE.CanvasTexture(sunCanvas);
        
        // Mercury - gray with craters
        const mercuryCanvas = document.createElement('canvas');
        mercuryCanvas.width = 256;
        mercuryCanvas.height = 256;
        const mercuryCtx = mercuryCanvas.getContext('2d');
        mercuryCtx.fillStyle = '#aaa';
        mercuryCtx.fillRect(0, 0, 256, 256);
        // Add craters
        for (let i = 0; i < 200; i++) {
          const x = Math.random() * 256;
          const y = Math.random() * 256;
          const r = Math.random() * 10 + 1;
          mercuryCtx.beginPath();
          mercuryCtx.arc(x, y, r, 0, Math.PI * 2);
          mercuryCtx.fillStyle = `rgba(60, 60, 60, ${Math.random() * 0.5 + 0.2})`;
          mercuryCtx.fill();
        }
        this.textures.mercury = new THREE.CanvasTexture(mercuryCanvas);
        
        // Venus - yellowish with cloud patterns
        const venusCanvas = document.createElement('canvas');
        venusCanvas.width = 256;
        venusCanvas.height = 256;
        const venusCtx = venusCanvas.getContext('2d');
        venusCtx.fillStyle = '#e6c229';
        venusCtx.fillRect(0, 0, 256, 256);
        // Cloud swirls
        for (let i = 0; i < 20; i++) {
          const x = Math.random() * 256;
          const y = Math.random() * 256;
          const r1 = Math.random() * 40 + 20;
          const r2 = r1 * 0.6;
          venusCtx.beginPath();
          venusCtx.ellipse(x, y, r1, r2, Math.random() * Math.PI, 0, Math.PI * 2);
          venusCtx.fillStyle = `rgba(230, 210, 160, ${Math.random() * 0.3 + 0.1})`;
          venusCtx.fill();
        }
        this.textures.venus = new THREE.CanvasTexture(venusCanvas);
        
        // Earth - load from URL since it's working
        // Load Earth texture from the URL that's working in your version
        try {
          const earthTexture = await new Promise((resolve, reject) => {
            const loader = new THREE.TextureLoader();
            loader.load(
              'https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/planets/earth_atmos_2048.jpg',
              resolve,
              undefined,
              reject
            );
          });
          this.textures.earth = earthTexture;
          console.log('Loaded Earth texture successfully');
        } catch (error) {
          console.warn('Failed to load Earth texture, using fallback', error);
          // Create fallback texture if needed (but you said Earth's texture works)
          const earthCanvas = document.createElement('canvas');
          earthCanvas.width = 256;
          earthCanvas.height = 256;
          const earthCtx = earthCanvas.getContext('2d');
          earthCtx.fillStyle = '#2233ff';
          earthCtx.fillRect(0, 0, 256, 256);
          // Add continents
          for (let i = 0; i < 7; i++) {
            const x = Math.random() * 256;
            const y = Math.random() * 256;
            const r1 = Math.random() * 50 + 20;
            const r2 = r1 * 0.7;
            earthCtx.beginPath();
            earthCtx.ellipse(x, y, r1, r2, Math.random() * Math.PI, 0, Math.PI * 2);
            earthCtx.fillStyle = 'rgba(34, 139, 34, 0.8)';
            earthCtx.fill();
          }
          this.textures.earth = new THREE.CanvasTexture(earthCanvas);
        }
        
        // Mars - red with dark regions and polar caps
        const marsCanvas = document.createElement('canvas');
        marsCanvas.width = 256;
        marsCanvas.height = 256;
        const marsCtx = marsCanvas.getContext('2d');
        marsCtx.fillStyle = '#c1440e';  // Rusty red
        marsCtx.fillRect(0, 0, 256, 256);
        // Dark regions
        for (let i = 0; i < 10; i++) {
          const x = Math.random() * 256;
          const y = Math.random() * 256;
          const r1 = Math.random() * 50 + 20;
          const r2 = r1 * 0.7;
          marsCtx.beginPath();
          marsCtx.ellipse(x, y, r1, r2, Math.random() * Math.PI, 0, Math.PI * 2);
          marsCtx.fillStyle = 'rgba(80, 30, 0, 0.3)';
          marsCtx.fill();
        }
        // North polar cap
        marsCtx.beginPath();
        marsCtx.ellipse(128, 30, 70, 40, 0, 0, Math.PI * 2);
        marsCtx.fillStyle = 'rgba(240, 240, 240, 0.7)';
        marsCtx.fill();
        // South polar cap (smaller)
        marsCtx.beginPath();
        marsCtx.ellipse(128, 226, 40, 25, 0, 0, Math.PI * 2);
        marsCtx.fillStyle = 'rgba(240, 240, 240, 0.7)';
        marsCtx.fill();
        this.textures.mars = new THREE.CanvasTexture(marsCanvas);
        
        // Jupiter - bands and Great Red Spot
        const jupiterCanvas = document.createElement('canvas');
        jupiterCanvas.width = 256;
        jupiterCanvas.height = 256;
        const jupiterCtx = jupiterCanvas.getContext('2d');
        // Draw bands
        const bands = 12;
        const bandHeight = 256 / bands;
        for (let i = 0; i < bands; i++) {
          jupiterCtx.fillStyle = i % 2 === 0 ? '#cfab6c' : '#b08d50';
          jupiterCtx.fillRect(0, i * bandHeight, 256, bandHeight);
        }
        // Great Red Spot
        jupiterCtx.beginPath();
        jupiterCtx.ellipse(180, 110, 30, 15, -0.2, 0, Math.PI * 2);
        jupiterCtx.fillStyle = '#d43b29';
        jupiterCtx.fill();
        this.textures.jupiter = new THREE.CanvasTexture(jupiterCanvas);
        
        // Saturn - similar to Jupiter but lighter
        const saturnCanvas = document.createElement('canvas');
        saturnCanvas.width = 256;
        saturnCanvas.height = 256;
        const saturnCtx = saturnCanvas.getContext('2d');
        // Draw bands
        for (let i = 0; i < bands; i++) {
          saturnCtx.fillStyle = i % 2 === 0 ? '#e2c88f' : '#c8b075';
          saturnCtx.fillRect(0, i * bandHeight, 256, bandHeight);
        }
        // Storm feature
        saturnCtx.beginPath();
        saturnCtx.ellipse(90, 90, 20, 20, 0, 0, Math.PI * 2);
        saturnCtx.fillStyle = '#e5d5a4';
        saturnCtx.fill();
        this.textures.saturn = new THREE.CanvasTexture(saturnCanvas);
        
        // Uranus - cyan with subtle bands
        const uranusCanvas = document.createElement('canvas');
        uranusCanvas.width = 256;
        uranusCanvas.height = 256;
        const uranusCtx = uranusCanvas.getContext('2d');
        uranusCtx.fillStyle = '#5eb2db';  // Cyan-blue
        uranusCtx.fillRect(0, 0, 256, 256);
        // Subtle bands
        for (let i = 0; i < 5; i++) {
          const y = 40 + i * 40;
          uranusCtx.fillStyle = 'rgba(150, 200, 220, 0.3)';
          uranusCtx.fillRect(0, y, 256, 20);
        }
        this.textures.uranus = new THREE.CanvasTexture(uranusCanvas);
        
        // Neptune - deep blue with white clouds
        const neptuneCanvas = document.createElement('canvas');
        neptuneCanvas.width = 256;
        neptuneCanvas.height = 256;
        const neptuneCtx = neptuneCanvas.getContext('2d');
        neptuneCtx.fillStyle = '#1a4fa5';  // Deep blue
        neptuneCtx.fillRect(0, 0, 256, 256);
        // Great Dark Spot
        neptuneCtx.beginPath();
        neptuneCtx.ellipse(160, 120, 25, 15, 0.3, 0, Math.PI * 2);
        neptuneCtx.fillStyle = 'rgba(10, 30, 70, 0.7)';
        neptuneCtx.fill();
        // White clouds
        for (let i = 0; i < 20; i++) {
          const x = Math.random() * 256;
          const y = Math.random() * 256;
          const r = Math.random() * 5 + 2;
          neptuneCtx.beginPath();
          neptuneCtx.arc(x, y, r, 0, Math.PI * 2);
          neptuneCtx.fillStyle = 'rgba(255, 255, 255, 0.7)';
          neptuneCtx.fill();
        }
        this.textures.neptune = new THREE.CanvasTexture(neptuneCanvas);
        
        // Moon - gray with craters
        const moonCanvas = document.createElement('canvas');
        moonCanvas.width = 256;
        moonCanvas.height = 256;
        const moonCtx = moonCanvas.getContext('2d');
        moonCtx.fillStyle = '#999';
        moonCtx.fillRect(0, 0, 256, 256);
        // Add craters
        for (let i = 0; i < 300; i++) {
          const x = Math.random() * 256;
          const y = Math.random() * 256;
          const r = Math.random() * 5 + 1;
          const alpha = Math.random() * 0.5 + 0.2;
          const isBright = Math.random() > 0.7;
          
          moonCtx.beginPath();
          moonCtx.arc(x, y, r, 0, Math.PI * 2);
          moonCtx.fillStyle = isBright 
            ? `rgba(200, 200, 200, ${alpha})`
            : `rgba(50, 50, 50, ${alpha})`;
          moonCtx.fill();
        }
        this.textures.moon = new THREE.CanvasTexture(moonCanvas);
        
        console.log('All textures created successfully');
      }

      createSun() {
        // Sun with glow effect
        const sunGeometry = new THREE.SphereGeometry(5, 32, 32);
        const sunMaterial = new THREE.MeshBasicMaterial({ 
          map: this.textures.sun,
          color: this.textures.sun ? 0xffffff : 0xffff00,
          emissive: 0xffff00,
          emissiveIntensity: 0.5
        });
        this.sunMesh = new THREE.Mesh(sunGeometry, sunMaterial);
        this.scene.add(this.sunMesh);

        // Add a simple glow effect using a larger transparent sphere
        const sunGlowGeometry = new THREE.SphereGeometry(6, 32, 32);
        const sunGlowMaterial = new THREE.MeshBasicMaterial({
          color: 0xffdd00,
          transparent: true,
          opacity: 0.3,
          side: THREE.BackSide
        });
        
        this.sunGlow = new THREE.Mesh(sunGlowGeometry, sunGlowMaterial);
        this.scene.add(this.sunGlow);
      }

      createPlanets() {
        // Planet data with more accurate parameters
        const planetData = [
          { name: "Mercury", distance: 8,  radius: 0.5, color: 0xaaaaaa, speed: 0.04, eccentricity: 0.2056, info: "Closest planet to the Sun. Has no atmosphere and a heavily cratered surface." },
          { name: "Venus",   distance: 12, radius: 1.0, color: 0xffcc99, speed: 0.015, eccentricity: 0.0068, info: "Similar in size to Earth but has a toxic atmosphere and extreme greenhouse effect, making it the hottest planet." },
          { name: "Earth",   distance: 16, radius: 1.0, color: 0x2233ff, speed: 0.01, eccentricity: 0.0167, info: "Our home planet, the only known celestial body to harbor life. Has one natural satellite, the Moon." },
          { name: "Mars",    distance: 20, radius: 0.8, color: 0xff3300, speed: 0.008, eccentricity: 0.0934, info: "Known as the Red Planet due to iron oxide (rust) on its surface. Has two small moons, Phobos and Deimos." },
          { name: "Jupiter", distance: 28, radius: 2.0, color: 0xffaa00, speed: 0.005, eccentricity: 0.0489, info: "The largest planet in our solar system. A gas giant with a prominent Great Red Spot and over 79 moons." },
          { name: "Saturn",  distance: 34, radius: 1.7, color: 0xffcc66, speed: 0.004, eccentricity: 0.0565, info: "Known for its spectacular ring system. A gas giant with at least 82 moons, including Titan." },
          { name: "Uranus",  distance: 40, radius: 1.2, color: 0x66ccff, speed: 0.003, eccentricity: 0.0463, info: "An ice giant that rotates on its side. Has a system of rings and 27 known moons." },
          { name: "Neptune", distance: 46, radius: 1.2, color: 0x3366cc, speed: 0.002, eccentricity: 0.0086, info: "The windiest planet, with the fastest recorded wind speeds. Has 14 known moons." }
        ];

        // Define moon data
        const moonScales = {
          "Earth": [{ scale: 0.27, texture: "moon" }],
          "Mars": [
            { scale: 0.003, texture: "moon" }, 
            { scale: 0.002, texture: "moon" }
          ],
          "Jupiter": [
            { scale: 0.026, texture: "moon" }, 
            { scale: 0.022, texture: "moon" }, 
            { scale: 0.038, texture: "moon" }, 
            { scale: 0.034, texture: "moon" }
          ],
          "Saturn": [{ scale: 0.044, texture: "moon" }],
          "Uranus": [{ scale: 0.03, texture: "moon" }],
          "Neptune": [{ scale: 0.055, texture: "moon" }]
        };

        // Create planets
        planetData.forEach(planet => {
          // Create planet mesh with texture
          const geometry = new THREE.SphereGeometry(planet.radius, 32, 32);
          // Use texture if available, otherwise use color
          const texture = this.textures[planet.name.toLowerCase()];
          const material = new THREE.MeshStandardMaterial({ 
            map: texture,
            color: texture ? 0xffffff : planet.color,
            metalness: 0,
            roughness: 1
          });
          const mesh = new THREE.Mesh(geometry, material);
          planet.mesh = mesh;
          // Initialize mean anomaly (M) to zero
          planet.M = 0;
          planet.a = planet.distance; // semi-major axis
          planet.e = planet.eccentricity;
          
          // Add rotation
          mesh.rotation.x = Math.random() * 0.1;
          planet.rotationSpeed = 0.005 / (1 + Math.random() * 0.2);
          
          this.scene.add(mesh);
          this.planets.push(planet);
          this.planetMeshes.set(planet.name, mesh);

          // Add label
          const labelDiv = document.createElement('div');
          labelDiv.className = 'planet-label';
          labelDiv.textContent = planet.name;
          const planetLabel = new CSS2DObject(labelDiv);
          planetLabel.position.set(0, planet.radius + 0.5, 0);
          mesh.add(planetLabel);
          planetLabel.visible = false;
          this.labels.push(planetLabel);

          // Create orbit path
          this.createOrbitPath(planet);

          // Add moons if applicable
          if (moonScales.hasOwnProperty(planet.name)) {
            this.addMoonsToplanet(planet, moonScales[planet.name]);
          }

          // Add Saturn's rings if it's Saturn
          if (planet.name === "Saturn") {
            this.addSaturnRings(planet);
          }
        });
      }

      createOrbitPath(planet) {
        const orbitSegments = 256; // More segments for smoother orbits
        const orbitMaterial = new THREE.LineBasicMaterial({ 
          color: 0xffffff, 
          transparent: true, 
          opacity: 0.3
        });
        
        // Create points for an elliptical orbit with more precise ellipse calculation
        const orbitPoints = [];
        const a = planet.a; // semi-major axis
        const e = planet.e; // eccentricity
        const b = a * Math.sqrt(1 - e * e); // semi-minor axis
        
        for (let i = 0; i <= orbitSegments; i++) {
          const angle = (i / orbitSegments) * Math.PI * 2;
          const r = (a * b) / Math.sqrt((b * Math.cos(angle)) ** 2 + (a * Math.sin(angle)) ** 2);
          orbitPoints.push(new THREE.Vector3(r * Math.cos(angle), 0, r * Math.sin(angle)));
        }
        
        const orbitGeometry = new THREE.BufferGeometry().setFromPoints(orbitPoints);
        const orbitLine = new THREE.Line(orbitGeometry, orbitMaterial);
        this.scene.add(orbitLine);
        this.orbitLines.push(orbitLine);
      }

      addMoonsToplanet(planet, moons) {
        let numMoons = moons.length;
        for (let i = 0; i < numMoons; i++) {
          const moonData = moons[i];
          const moonOrbit = new THREE.Object3D();
          
          // Distribute moons evenly
          moonOrbit.rotation.y = (i / numMoons) * Math.PI * 2;
          
          // Adjust orbit speed based on planet
          let orbitSpeed = 0.05;
          if (planet.name === "Mars") {
            orbitSpeed = (i % 2 === 0) ? 0.06 : 0.04;
          } else if (planet.name === "Jupiter") {
            const speeds = [0.03, 0.025, 0.02, 0.015];
            orbitSpeed = speeds[i];
          } else if (planet.name === "Saturn") {
            orbitSpeed = 0.035;
          }
          moonOrbit.userData.orbitSpeed = orbitSpeed;
          
          // Create moon
          const moonGeometry = new THREE.SphereGeometry(planet.radius * moonData.scale, 16, 16);
          const moonTexture = this.textures[moonData.texture];
          const moonMaterial = new THREE.MeshStandardMaterial({ 
            map: moonTexture,
            color: moonTexture ? 0xffffff : 0x888888,
            roughness: 1
          });
          const moonMesh = new THREE.Mesh(moonGeometry, moonMaterial);
          
          // Position moon
          const distanceFromPlanet = planet.radius + 1 + i * 0.7;
          moonMesh.position.set(distanceFromPlanet, 0, 0);
          
          // Add moon to orbit
          moonOrbit.add(moonMesh);
          planet.mesh.add(moonOrbit);
        }
      }

      addSaturnRings(planet) {
        // Create multiple rings for more detail
        const ringColors = [0xcccccc, 0xbbbbbb, 0xaaaaaa];
        const ringRadii = [
          { inner: planet.radius * 1.2, outer: planet.radius * 1.8 },
          { inner: planet.radius * 1.9, outer: planet.radius * 2.1 },
          { inner: planet.radius * 2.2, outer: planet.radius * 2.5 }
        ];
        
        ringRadii.forEach((ring, index) => {
          const ringGeometry = new THREE.RingGeometry(ring.inner, ring.outer, 64);
          
          // Create custom UV mapping for the ring geometry
          const pos = ringGeometry.attributes.position;
          const v3 = new THREE.Vector3();
          const ringUV = [];

          for (let i = 0; i < pos.count; i++) {
            v3.fromBufferAttribute(pos, i);
            const distance = v3.length();
            const normalized = (distance - ring.inner) / (ring.outer - ring.inner);
            ringUV.push(normalized, 0);
          }

          ringGeometry.setAttribute('uv', new THREE.Float32BufferAttribute(ringUV, 2));
          
          // Create ring material
          const ringMaterial = new THREE.MeshStandardMaterial({
            color: ringColors[index],
            side: THREE.DoubleSide,
            transparent: true,
            opacity: 0.8 - (index * 0.1),
            roughness: 0.7,
            metalness: 0.2
          });
          
          const ringMesh = new THREE.Mesh(ringGeometry, ringMaterial);
          ringMesh.rotation.x = Math.PI / 2;
          planet.mesh.add(ringMesh);
        });
      }

      createAsteroidBelt() {
        // Create asteroid belt using instanced mesh for better performance
        const asteroidCount = 500; // Increased for more density
        const asteroidGeometry = new THREE.SphereGeometry(0.1, 8, 8);
        const asteroidMaterial = new THREE.MeshStandardMaterial({ 
          color: 0x888888,
          roughness: 0.9,
          metalness: 0.1
        });
        
        // Create dummy for instancing
        this.asteroidMesh = new THREE.InstancedMesh(
          asteroidGeometry, 
          asteroidMaterial,
          asteroidCount
        );
        
        this.scene.add(this.asteroidMesh);
        
        // Create and store asteroid data
        const dummy = new THREE.Object3D();
        for (let i = 0; i < asteroidCount; i++) {
          const angle = Math.random() * Math.PI * 2;
          // Random radius within asteroid belt range with variation
          const radius = THREE.MathUtils.randFloat(22, 26);
          const yOffset = THREE.MathUtils.randFloatSpread(3); // More vertical spread
          
          // Set position
          dummy.position.set(
            radius * Math.cos(angle),
            yOffset,
            radius * Math.sin(angle)
          );
          
          // Randomize size
          const scale = THREE.MathUtils.randFloat(0.05, 0.15);
          dummy.scale.set(scale, scale, scale);
          
          // Random rotation
          dummy.rotation.set(
            Math.random() * Math.PI,
            Math.random() * Math.PI,
            Math.random() * Math.PI
          );
          
          // Update matrix
          dummy.updateMatrix();
          this.asteroidMesh.setMatrixAt(i, dummy.matrix);
          
          // Store asteroid data for animation
          this.asteroids.push({
            index: i,
            angle: angle,
            radius: radius,
            yOffset: yOffset,
            speed: THREE.MathUtils.randFloat(0.0005, 0.002),
            rotationSpeed: {
              x: THREE.MathUtils.randFloatSpread(0.01),
              y: THREE.MathUtils.randFloatSpread(0.01),
              z: THREE.MathUtils.randFloatSpread(0.01)
            }
          });
        }
        
        this.asteroidMesh.instanceMatrix.needsUpdate = true;
      }

      createUFO() {
        // Create UFO with improved design
        this.ufo = new THREE.Group();
        
        // Base disc
        const discGeometry = new THREE.CylinderGeometry(1.5, 1.5, 0.3, 32);
        const discMaterial = new THREE.MeshStandardMaterial({ 
          color: 0x888888, 
          metalness: 0.8, 
          roughness: 0.2 
        });
        const discMesh = new THREE.Mesh(discGeometry, discMaterial);
        this.ufo.add(discMesh);
        
        // Top dome
        const domeGeometry = new THREE.SphereGeometry(0.8, 16, 16, 0, Math.PI * 2, 0, Math.PI / 2);
        const domeMaterial = new THREE.MeshStandardMaterial({ 
          color: 0x99ccff, 
          metalness: 0.5, 
          roughness: 0.3,
          transparent: true,
          opacity: 0.8
        });
        const domeMesh = new THREE.Mesh(domeGeometry, domeMaterial);
        domeMesh.position.y = 0.3;
        this.ufo.add(domeMesh);
        
        // Add lights to UFO
        const lightColors = [0xff0000, 0x00ff00, 0x0000ff, 0xffff00];
        for (let i = 0; i < 4; i++) {
          const angle = (i / 4) * Math.PI * 2;
          const lightGeometry = new THREE.SphereGeometry(0.15, 8, 8);
          const lightMaterial = new THREE.MeshBasicMaterial({ 
            color: lightColors[i],
            emissive: lightColors[i],
            emissiveIntensity: 1
          });
          const light = new THREE.Mesh(lightGeometry, lightMaterial);
          light.position.set(
            Math.cos(angle) * 1.2,
            -0.1,
            Math.sin(angle) * 1.2
          );
          this.ufo.add(light);
          
          // Add point light
          const pointLight = new THREE.PointLight(lightColors[i], 0.5, 5);
          pointLight.position.copy(light.position);
          this.ufo.add(pointLight);
        }
        
        // Add to scene and position
        this.scene.add(this.ufo);
        this.ufo.position.set(0, 5, 0);
        this.ufo.scale.set(0.5, 0.5, 0.5);
        
        // UFO state variables
        this.ufoState = "random";
        this.ufoRandomTarget = new THREE.Vector3();
        this.ufoSpeed = 0.2;
        this.ufoOrbitPlanet = null;
        this.ufoOrbitAngle = 0;
        this.ufoOrbitRadius = 0;
        this.ufoOrbitTime = 0;
        this.ufoVisible = true;
        
        // Set initial random target
        this.setRandomUfoTarget();
      }

      setRandomUfoTarget() {
        this.ufoRandomTarget.set(
          THREE.MathUtils.randFloatSpread(100),
          THREE.MathUtils.randFloat(2, 15),
          THREE.MathUtils.randFloatSpread(100)
        );
      }

      createStarfield() {
        // Create a starfield that's much more distant from the solar system
        const starCount = 15000;
        const starsGeometry = new THREE.BufferGeometry();
        const positions = new Float32Array(starCount * 3);
        
        for (let i = 0; i < starCount * 3; i += 3) {
          // Position stars in a much larger sphere (5x more distant)
          const radius = THREE.MathUtils.randFloat(1000, 5000);
          const theta = THREE.MathUtils.randFloat(0, Math.PI * 2);
          const phi = THREE.MathUtils.randFloat(0, Math.PI);
          
          positions[i] = radius * Math.sin(phi) * Math.cos(theta);
          positions[i + 1] = radius * Math.sin(phi) * Math.sin(theta);
          positions[i + 2] = radius * Math.cos(phi);
        }
        
        starsGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        
        // Simple point material with size attenuation
        const starsMaterial = new THREE.PointsMaterial({
          color: 0xffffff,
          size: 4, // Larger size to compensate for distance
          sizeAttenuation: true,
          transparent: true,
          alphaTest: 0.5
        });
        
        this.stars = new THREE.Points(starsGeometry, starsMaterial);
        this.scene.add(this.stars);
      }

      setupEventListeners() {
        // Handle window resizing
        window.addEventListener('resize', () => this.onWindowResize());
        
        // Toggle orbit lines
        const toggleButton = document.getElementById('toggleOrbits');
        this.orbitsVisible = true;
        toggleButton.addEventListener('click', () => this.toggleOrbits());
        
        // Toggle planet labels
        const labelsButton = document.getElementById('toggleLabels');
        this.labelsVisible = false;
        labelsButton.addEventListener('click', () => this.toggleLabels());
        
        // Reset camera
        const resetButton = document.getElementById('resetCamera');
        resetButton.addEventListener('click', () => this.resetCamera());
        
        // Toggle UFO
        const ufoButton = document.getElementById('toggleUFO');
        ufoButton.addEventListener('click', () => this.toggleUFO());
        
        // Display planet info on hover
        this.renderer.domElement.addEventListener('mousemove', (event) => this.onMouseMove(event));
      }

      onWindowResize() {
        this.camera.aspect = window.innerWidth / window.innerHeight;
        this.camera.updateProjectionMatrix();
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        this.labelRenderer.setSize(window.innerWidth, window.innerHeight);
      }

      toggleOrbits() {
        this.orbitsVisible = !this.orbitsVisible;
        this.orbitLines.forEach(line => {
          line.visible = this.orbitsVisible;
        });
      }

      toggleLabels() {
        this.labelsVisible = !this.labelsVisible;
        this.labels.forEach(label => {
          label.visible = this.labelsVisible;
        });
      }

      resetCamera() {
        // Smoothly animate camera back to initial position
        const startPosition = this.camera.position.clone();
        const endPosition = new THREE.Vector3(0, 50, 100);
        const duration = 1000; // ms
        const startTime = Date.now();
        
        const animate = () => {
          const elapsed = Date.now() - startTime;
          if (elapsed < duration) {
            const t = elapsed / duration;
            // Ease in-out function
            const factor = t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
            
            this.camera.position.lerpVectors(startPosition, endPosition, factor);
            this.controls.target.set(0, 0, 0);
            this.controls.update();
            
            requestAnimationFrame(animate);
          } else {
            this.camera.position.copy(endPosition);
            this.controls.target.set(0, 0, 0);
            this.controls.update();
          }
        };
        
        animate();
      }

      toggleUFO() {
        this.ufoVisible = !this.ufoVisible;
        this.ufo.visible = this.ufoVisible;
      }

      onMouseMove(event) {
        // Cast a ray to check for planet intersections
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        
        // Calculate mouse position in normalized device coordinates
        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
        
        raycaster.setFromCamera(mouse, this.camera);
        
        // Get all planet meshes
        const planetObjects = [];
        this.planets.forEach(planet => {
          planetObjects.push(planet.mesh);
        });
        
        const intersects = raycaster.intersectObjects(planetObjects);
        
        const infoPanel = document.getElementById('infoPanel');
        const planetName = document.getElementById('planetName');
        const planetInfo = document.getElementById('planetInfo');
        
        if (intersects.length > 0) {
          // Find which planet was intersected
          const intersectedMesh = intersects[0].object;
          let selectedPlanet = null;
          
          for (const planet of this.planets) {
            if (planet.mesh === intersectedMesh) {
              selectedPlanet = planet;
              break;
            }
          }
          
          if (selectedPlanet) {
            planetName.textContent = selectedPlanet.name;
            planetInfo.textContent = selectedPlanet.info;
            infoPanel.style.display = 'block';
          }
        } else {
          infoPanel.style.display = 'none';
        }
      }

      // Kepler solver optimized for repeated calculations
      solveKepler(M, e) {
        let E = M; // Initial guess
        
        // Newton-Raphson iterations with early stopping
        const epsilon = 1e-8;
        for (let i = 0; i < 6; i++) {
          const f = E - e * Math.sin(E) - M;
          const fPrime = 1 - e * Math.cos(E);
          const delta = f / fPrime;
          E = E - delta;
          
          // Stop if we've reached sufficient precision
          if (Math.abs(delta) < epsilon) break;
        }
        
        return E;
      }

      trueAnomaly(E, e) {
        return 2 * Math.atan(Math.sqrt((1 + e)/(1 - e)) * Math.tan(E/2));
      }

      updatePlanets(deltaTime) {
        // Update each planet's position and rotation
        this.planets.forEach(planet => {
          // Update mean anomaly
          planet.M += planet.speed * deltaTime;
          
          // Solve Kepler's equation
          const E = this.solveKepler(planet.M, planet.e);
          const f = this.trueAnomaly(E, planet.e);
          
          // Calculate position on elliptical orbit
          const r = planet.a * (1 - planet.e * planet.e) / (1 + planet.e * Math.cos(f));
          planet.mesh.position.set(
            r * Math.cos(f),
            0,
            r * Math.sin(f)
          );
          
          // Rotate the planet
          planet.mesh.rotation.y += planet.rotationSpeed * deltaTime;
        });
      }

      updateMoons() {
        // Update all moon orbits
        this.scene.traverse(object => {
          if (object.userData && object.userData.orbitSpeed) {
            object.rotation.y += object.userData.orbitSpeed;
          }
        });
      }

      updateAsteroids(deltaTime) {
        // Update asteroid positions
        const dummy = new THREE.Object3D();
        
        this.asteroids.forEach((asteroid, i) => {
          // Update angle
          asteroid.angle += asteroid.speed * deltaTime;
          
          // Calculate new position
          const x = asteroid.radius * Math.cos(asteroid.angle);
          const y = asteroid.yOffset;
          const z = asteroid.radius * Math.sin(asteroid.angle);
          
          // Update instanced mesh
          this.asteroidMesh.getMatrixAt(i, dummy.matrix);
          dummy.position.set(x, y, z);
          
          // Rotate asteroid
          dummy.rotation.x += asteroid.rotationSpeed.x * deltaTime;
          dummy.rotation.y += asteroid.rotationSpeed.y * deltaTime;
          dummy.rotation.z += asteroid.rotationSpeed.z * deltaTime;
          
          dummy.updateMatrix();
          this.asteroidMesh.setMatrixAt(i, dummy.matrix);
        });
        
        this.asteroidMesh.instanceMatrix.needsUpdate = true;
      }

      updateUFO(deltaTime) {
        if (!this.ufoVisible) return;
        
        // Update UFO position and behavior
        if (this.ufoState === "random") {
          // Move towards target
          let direction = new THREE.Vector3().subVectors(this.ufoRandomTarget, this.ufo.position);
          let distance = direction.length();
          
          if (distance < 1) {
            this.setRandomUfoTarget();
          } else {
            direction.normalize();
            this.ufo.position.add(direction.multiplyScalar(this.ufoSpeed * deltaTime * 60));
          }
          
          // Check if close to a planet
          for (let planet of this.planets) {
            let planetPos = planet.mesh.position;
            const distanceToPlanet = this.ufo.position.distanceTo(planetPos);
            
            if (distanceToPlanet < (planet.radius + 3)) {
              if (Math.random() < 0.005) {
                // Start orbiting this planet
                this.ufoState = "orbiting";
                this.ufoOrbitPlanet = planet;
                this.ufoOrbitRadius = planet.radius + 3;
                this.ufoOrbitAngle = Math.random() * Math.PI * 2;
                this.ufoOrbitTime = 200 + Math.floor(Math.random() * 200);
                break;
              }
            }
          }
        } else if (this.ufoState === "orbiting") {
          if (this.ufoOrbitPlanet) {
            // Get planet position
            let planetPos = new THREE.Vector3();
            this.ufoOrbitPlanet.mesh.getWorldPosition(planetPos);
            
            // Update orbit angle
            this.ufoOrbitAngle += 0.05 * deltaTime * 60;
            
            // Calculate position around planet with some up-down movement
            let orbitX = planetPos.x + this.ufoOrbitRadius * Math.cos(this.ufoOrbitAngle);
            let orbitZ = planetPos.z + this.ufoOrbitRadius * Math.sin(this.ufoOrbitAngle);
            let orbitY = planetPos.y + 2 + Math.sin(this.ufoOrbitAngle * 2) * 0.5;
            
            this.ufo.position.set(orbitX, orbitY, orbitZ);
          }
          
          // Countdown orbit time
          this.ufoOrbitTime -= deltaTime * 60;
          if (this.ufoOrbitTime <= 0) {
            // Switch back to random movement
            this.ufoState = "random";
            this.setRandomUfoTarget();
          }
        }
        
        // Rotate UFO
        this.ufo.rotation.y += 0.02 * deltaTime * 60;
      }

      updateSun() {
        // No need to update sun glow since we're using a simple sphere now
      }

      hideLoading() {
        const loadingScreen = document.querySelector('.loading');
        loadingScreen.style.opacity = '0';
        setTimeout(() => {
          loadingScreen.style.display = 'none';
        }, 1000);
      }

      animate() {
        requestAnimationFrame(() => this.animate());
        
        const deltaTime = this.clock.getDelta();
        
        // Update all elements
        this.updatePlanets(deltaTime);
        this.updateMoons();
        this.updateAsteroids(deltaTime);
        this.updateUFO(deltaTime);
        this.updateSun();
        
        // Update controls
        this.controls.update();
        
        // Render
        this.renderer.render(this.scene, this.camera);
        this.labelRenderer.render(this.scene, this.camera);
      }
    }

    // Initialize the solar system
    const solarSystem = new SolarSystem();

  </script>
</body>
</html>