<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Flappy Bird - Nutrition Quiz</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }
        #game-container {
            position: relative;
            width: 100%;
            height: 100vh;
        }
        canvas {
            display: block;
        }
        #start-screen, #game-over-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            text-align: center;
            z-index: 10;
        }
        #game-over-screen {
            display: none;
        }
        h1 {
            font-size: 3em;
            margin-bottom: 0.5em;
            color: #f8e71c;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
        }
        button {
            padding: 15px 30px;
            font-size: 1.5em;
            background-color: #f8e71c;
            border: none;
            border-radius: 8px;
            color: #333;
            cursor: pointer;
            transition: all 0.3s;
            margin-top: 20px;
        }
        button:hover {
            background-color: #fff;
            transform: scale(1.05);
        }
        #score-display {
            position: absolute;
            top: 20px;
            right: 20px;
            font-size: 2em;
            color: white;
            z-index: 5;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.7);
        }
        #instructions {
            max-width: 500px;
            margin: 20px;
            font-size: 1.2em;
            line-height: 1.5;
        }
        
        /* Question modal styles */
        #question-modal {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            z-index: 20;
            display: none;
            width: 80%;
            max-width: 600px;
            box-shadow: 0 0 30px rgba(0, 0, 0, 0.8);
        }
        
        #question-text {
            font-size: 1.5em;
            margin-bottom: 20px;
            color: #f8e71c;
        }
        
        #answers {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
        }
        
        .answer-btn {
            padding: 12px 20px;
            font-size: 1.2em;
            background-color: #4169E1;
            border: none;
            border-radius: 8px;
            color: white;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .answer-btn:hover {
            background-color: #6495ED;
            transform: scale(1.03);
        }
        
        @media (max-width: 768px) {
            #answers {
                grid-template-columns: 1fr;
            }
            
            #question-text {
                font-size: 1.2em;
            }
        }
    </style>
    <script src="../js/showcase-nav.js"></script>
</head>
<body>
    <div id="game-container">
        <div id="score-display">Score: 0</div>
        <div id="start-screen">
            <h1>3D FLAPPY BIRD</h1>
            <div id="instructions">
                Click or press SPACEBAR to make the bird fly through the obstacles.
                Navigate through the moving pipes to score points.
                Answer nutrition questions correctly to earn bonus points!
                Avoid hitting the pipes or the ground!
            </div>
            <button id="start-button">START GAME</button>
        </div>
        <div id="game-over-screen">
            <h1>GAME OVER</h1>
            <div id="final-score">Score: 0</div>
            <button id="restart-button">PLAY AGAIN</button>
        </div>
        
        <!-- Question Modal -->
        <div id="question-modal">
            <h2 id="question-text">Question goes here?</h2>
            <div id="answers"></div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Game variables
        let scene, camera, renderer, bird, pipes = [], particles = [];
        let score = 0;
        let gameStarted = false;
        let gameOver = false;
        let clock = new THREE.Clock();
        let velocity = 0;
        let gravity = 0.8;
        let jump = -1.8;
        let lastPipeTime = 0;
        let birdBox;
        let ambientLight, directionalLight, pointLight;
        let particleSystem, particleCount = 500;
        let skybox;
        let groundMesh;
        let questionShowing = false;
        let questionChance = 0.5; // 50% chance to show a question after passing pipes
        let clouds = [];
        
        // The nutrition questions database
        const questions = [
  {
    question: "What ethical principle focuses on ensuring AI systems don't harm users?",
    answers: ["Transparency", "Non-maleficence", "Autonomy", "Justice"],
    correct: 1
  },
  {
    question: "What is the main concern with AI data privacy in education?",
    answers: ["Cost", "Student data protection", "Speed of processing", "Hardware requirements"],
    correct: 1
  },
  {
    question: "What is AI bias?",
    answers: ["When AI performs faster than expected", "When AI systems show systematic unfairness", "When AI processes large volumes of data", "When AI has limited capabilities"],
    correct: 1
  },
  {
    question: "Which is NOT a responsible approach to AI in education?",
    answers: ["Getting informed consent", "Explaining AI limitations", "Replacing teacher judgment entirely", "Monitoring for bias"],
    correct: 2
  },
  {
    question: "What is 'hallucination' in AI language models?",
    answers: ["Processing images", "Creating false information", "Learning from feedback", "Translating languages"],
    correct: 1
  },
  {
    question: "Who bears primary responsibility for AI-generated educational content?",
    answers: ["The AI model", "The AI company", "The teacher using the AI", "The students"],
    correct: 2
  },
  {
    question: "What should you do when AI generates factually incorrect information?",
    answers: ["Accept it anyway", "Fact-check against reliable sources", "Assume it must be new information", "Share it without verification"],
    correct: 1
  },
  {
    question: "What is a key concern when using AI-generated images in teaching?",
    answers: ["Image quality", "Processing time", "Copyright infringement", "File size"],
    correct: 2
  },
  {
    question: "Which practice best supports ethical AI use in classrooms?",
    answers: ["Using AI secretly", "Being transparent about AI use", "Ignoring potential biases", "Relying solely on AI assessment"],
    correct: 1
  },
  {
    question: "What is digital literacy in the context of AI?",
    answers: ["Computer programming skills", "The ability to critically evaluate AI outputs", "Speed-reading digital content", "Creating digital art"],
    correct: 1
  },
  {
    question: "What should teachers do when using AI-generated resources?",
    answers: ["Claim them as self-created", "Rely on them without review", "Verify accuracy and appropriateness", "Use only for advanced students"],
    correct: 2
  },
  {
    question: "Which AI application requires the most careful ethical consideration?",
    answers: ["Spell checking essays", "Generating practice math problems", "Automated student assessment", "Creating lesson plan outlines"],
    correct: 2
  },
  {
    question: "What is 'prompt engineering'?",
    answers: ["Hardware configuration", "Writing effective instructions for AI", "Computer programming", "Designing robots"],
    correct: 1
  },
  {
    question: "What concept refers to AI systems potentially functioning beyond human control?",
    answers: ["AI alignment", "AI singularity", "AI bias", "AI fairness"],
    correct: 1
  },
  {
    question: "What is NOT typically considered personal data when using educational AI?",
    answers: ["Student names", "Anonymous curriculum statistics", "Student home addresses", "Individual grades"],
    correct: 1
  },
  {
    question: "What does 'model drift' refer to in AI systems?",
    answers: ["AI becoming more accurate", "AI forgetting previous training", "AI becoming outdated as the world changes", "AI hardware malfunctioning"],
    correct: 2
  },
  {
    question: "Which practice helps reduce AI bias?",
    answers: ["Using a single data source", "Training with diverse, representative data", "Limiting model parameters", "Reducing processing power"],
    correct: 1
  },
  {
    question: "What is a key benefit of human-AI collaboration in education?",
    answers: ["Reducing teacher workload completely", "Combining AI efficiency with human judgment", "Eliminating the need for lesson planning", "Removing subjective assessment"],
    correct: 1
  },
  {
    question: "What is 'AI literacy'?",
    answers: ["AI reading ability", "Understanding how to use and evaluate AI", "Programming algorithms", "Teaching robots to read"],
    correct: 1
  },
  {
    question: "What should teachers consider when using AI for student assessment?",
    answers: ["It's always objective", "It should completely replace teacher judgment", "It may contain biases", "It's perfect for evaluating creativity"],
    correct: 2
  },
  {
    question: "Which represents appropriate transparency about AI use?",
    answers: ["Hiding AI use from students", "Informing parents AI is being used", "Only telling school leadership", "Only mentioning it if asked directly"],
    correct: 1
  },
  {
    question: "What is an important consideration when using AI chatbots with students?",
    answers: ["They will always provide correct information", "Students need guidance on their limitations", "They're only suitable for advanced students", "They should replace teacher explanations"],
    correct: 1
  },
  {
    question: "What should be considered when using AI to create differentiated materials?",
    answers: ["AI needs no supervision for this task", "Simplification might lose important nuance", "It's only useful for advanced content", "It works best with fictional content"],
    correct: 1
  },
  {
    question: "Which is NOT a recommended practice for AI safety in education?",
    answers: ["Periodic review of AI-generated content", "Cross-checking AI information", "Blind trust in AI outputs", "Clear attribution of AI-generated materials"],
    correct: 2
  },
  {
    question: "What approach best addresses AI ethical concerns in schools?",
    answers: ["Avoiding AI use entirely", "Developing clear usage policies", "Limiting AI to administrators only", "Using it without explicit guidelines"],
    correct: 1
  },
  {
    question: "What is 'data poisoning' in AI systems?",
    answers: ["Using expired data", "Deliberately contaminating training data", "Encrypting sensitive information", "Compressing large datasets"],
    correct: 1
  },
  {
    question: "What principle suggests AI should enhance rather than replace human capabilities?",
    answers: ["Automation", "Augmentation", "Autonomy", "Accuracy"],
    correct: 1
  },
  {
    question: "What is a primary concern with AI-generated feedback on student work?",
    answers: ["It's too slow", "It may lack personal connection", "It uses too much electricity", "It's always too critical"],
    correct: 1
  },
  {
    question: "What practice helps ensure AI is used ethically in education?",
    answers: ["Using it without student knowledge", "Regular ethical review and reflection", "Maximizing automation", "Focusing only on academic content"],
    correct: 1
  },
  {
    question: "Which statement best represents the concept of 'AI alignment'?",
    answers: ["Making AI physically secure", "Ensuring AI follows a specific programming language", "Making AI systems that act according to human values", "Creating AI that works identically across devices"],
    correct: 2
  }
];
        
        // Initialize game
        function init() {
            // Create scene
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x87CEEB, 0.01);
            
            // Create camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 0, 15);
            
            // Create renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(0x87CEEB);
            renderer.shadowMap.enabled = true;
            document.getElementById('game-container').appendChild(renderer.domElement);
            
            // Create skybox
            createSkybox();
            
            // Create lights
            createLights();
            
            // Create ground
            createGround();
            
            // Create bird
            createBird();
            
            // Create particle system
            createParticleSystem();
            
            // Event listeners
            window.addEventListener('resize', onWindowResize);
            window.addEventListener('mousedown', flapBird);
            window.addEventListener('keydown', function(e) {
                if (e.code === 'Space') {
                    flapBird();
                }
            });
            
            document.getElementById('start-button').addEventListener('click', startGame);
            document.getElementById('restart-button').addEventListener('click', restartGame);
            
            // Start animation loop
            animate();
        }
        
        function createSkybox() {
            const skyGeometry = new THREE.BoxGeometry(1000, 1000, 1000);
            const skyMaterials = [
                new THREE.MeshBasicMaterial({ color: 0x6BBBFF, side: THREE.BackSide }), // right
                new THREE.MeshBasicMaterial({ color: 0x6BBBFF, side: THREE.BackSide }), // left
                new THREE.MeshBasicMaterial({ color: 0x4CA3FF, side: THREE.BackSide }), // top
                new THREE.MeshBasicMaterial({ color: 0x88CCFF, side: THREE.BackSide }), // bottom
                new THREE.MeshBasicMaterial({ color: 0x6BBBFF, side: THREE.BackSide }), // front
                new THREE.MeshBasicMaterial({ color: 0x6BBBFF, side: THREE.BackSide })  // back
            ];
            
            skybox = new THREE.Mesh(skyGeometry, skyMaterials);
            scene.add(skybox);
            
            // Add some clouds
            for (let i = 0; i < 20; i++) {
                createCloud(
                    Math.random() * 200 - 100,
                    Math.random() * 60 - 10,
                    Math.random() * 100 - 150
                );
            }
        }
        
        function createCloud(x, y, z) {
            const cloudGroup = new THREE.Group();
            const cloudMaterial = new THREE.MeshPhongMaterial({
                color: 0xffffff,
                emissive: 0x444444,
                specular: 0xffffff,
                shininess: 10
            });
            
            const sizes = [1.5, 1.2, 1.7, 1.3, 1.4];
            const positions = [
                [0, 0, 0],
                [1, 0.3, 0],
                [-1, 0.2, 0],
                [0.5, -0.2, 0.5],
                [-0.5, -0.3, -0.5]
            ];
            
            for (let i = 0; i < 5; i++) {
                const puffGeo = new THREE.SphereGeometry(sizes[i], 8, 8);
                const puff = new THREE.Mesh(puffGeo, cloudMaterial);
                puff.position.set(positions[i][0], positions[i][1], positions[i][2]);
                cloudGroup.add(puff);
            }
            
            cloudGroup.position.set(x, y, z);
            cloudGroup.scale.set(2, 1.5, 1.5);
            scene.add(cloudGroup);
            
            // Store cloud with its speed for animation
            clouds.push({
                mesh: cloudGroup,
                speed: Math.random() * 0.03 + 0.01
            });
        }
        
        function createLights() {
            // Ambient light
            ambientLight = new THREE.AmbientLight(0x404040, 0.6);
            scene.add(ambientLight);
            
            // Directional light (sun)
            directionalLight = new THREE.DirectionalLight(0xFFFFFF, 0.8);
            directionalLight.position.set(50, 50, 10);
            directionalLight.castShadow = true;
            directionalLight.shadow.camera.near = 1;
            directionalLight.shadow.camera.far = 500;
            directionalLight.shadow.camera.left = -50;
            directionalLight.shadow.camera.right = 50;
            directionalLight.shadow.camera.top = 50;
            directionalLight.shadow.camera.bottom = -50;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            scene.add(directionalLight);
            
            // Point light (following bird)
            pointLight = new THREE.PointLight(0xFFFF99, 0.8, 20);
            pointLight.castShadow = true;
            scene.add(pointLight);
        }
        
        function createGround() {
            // Create ground plane
            const groundGeo = new THREE.PlaneGeometry(300, 300, 20, 20);
            const groundMat = new THREE.MeshPhongMaterial({
                color: 0x8BC34A,
                shininess: 10,
                side: THREE.DoubleSide
            });
            
            groundMesh = new THREE.Mesh(groundGeo, groundMat);
            groundMesh.rotation.x = Math.PI / 2;
            groundMesh.position.y = -10;
            groundMesh.receiveShadow = true;
            scene.add(groundMesh);
            
            // Add ground details
            const grassCount = 200;
            for (let i = 0; i < grassCount; i++) {
                const x = Math.random() * 200 - 100;
                const z = Math.random() * 200 - 100;
                
                const grassGeo = new THREE.BoxGeometry(0.2, 0.5, 0.1);
                const grassMat = new THREE.MeshLambertMaterial({
                    color: Math.random() > 0.5 ? 0x7CB342 : 0x9CCC65
                });
                
                const grass = new THREE.Mesh(grassGeo, grassMat);
                grass.position.set(x, -9.75, z);
                grass.castShadow = true;
                grass.receiveShadow = true;
                scene.add(grass);
            }
        }
        
        function createBird() {
            // Create bird group
            bird = new THREE.Group();
            
            // Bird body
            const bodyGeo = new THREE.SphereGeometry(1, 32, 32);
            const bodyMat = new THREE.MeshPhongMaterial({
                color: 0xFFEB3B,
                emissive: 0x333333,
                shininess: 30
            });
            const bodyMesh = new THREE.Mesh(bodyGeo, bodyMat);
            bodyMesh.castShadow = true;
            bird.add(bodyMesh);
            
            // Bird eyes
            const eyeGeo = new THREE.SphereGeometry(0.2, 16, 16);
            const eyeMat = new THREE.MeshPhongMaterial({
                color: 0xFFFFFF,
                shininess: 70
            });
            
            const leftEye = new THREE.Mesh(eyeGeo, eyeMat);
            leftEye.position.set(0.6, 0.3, 0.7);
            bird.add(leftEye);
            
            const rightEye = new THREE.Mesh(eyeGeo, eyeMat);
            rightEye.position.set(0.6, 0.3, -0.7);
            bird.add(rightEye);
            
            // Pupils
            const pupilGeo = new THREE.SphereGeometry(0.1, 16, 16);
            const pupilMat = new THREE.MeshBasicMaterial({ color: 0x000000 });
            
            const leftPupil = new THREE.Mesh(pupilGeo, pupilMat);
            leftPupil.position.set(0.7, 0.3, 0.7);
            bird.add(leftPupil);
            
            const rightPupil = new THREE.Mesh(pupilGeo, pupilMat);
            rightPupil.position.set(0.7, 0.3, -0.7);
            bird.add(rightPupil);
            
            // Beak
            const beakGeo = new THREE.ConeGeometry(0.3, 1, 16);
            const beakMat = new THREE.MeshPhongMaterial({
                color: 0xFF5722,
                shininess: 20
            });
            const beak = new THREE.Mesh(beakGeo, beakMat);
            beak.rotation.z = -Math.PI / 2;
            beak.position.set(1.1, 0, 0);
            beak.castShadow = true;
            bird.add(beak);
            
            // Wings
            const wingGeo = new THREE.BoxGeometry(1, 0.1, 1.5);
            const wingMat = new THREE.MeshPhongMaterial({
                color: 0xFBC02D,
                shininess: 20
            });
            
            const leftWing = new THREE.Mesh(wingGeo, wingMat);
            leftWing.position.set(0, 0, 1.1);
            leftWing.castShadow = true;
            bird.add(leftWing);
            
            const rightWing = new THREE.Mesh(wingGeo, wingMat);
            rightWing.position.set(0, 0, -1.1);
            rightWing.castShadow = true;
            bird.add(rightWing);
            
            // Bird tail
            const tailGeo = new THREE.BoxGeometry(1, 0.5, 0.8);
            const tailMat = new THREE.MeshPhongMaterial({
                color: 0xFDD835,
                shininess: 20
            });
            const tail = new THREE.Mesh(tailGeo, tailMat);
            tail.position.set(-1, 0, 0);
            tail.castShadow = true;
            bird.add(tail);
            
            // Add bird to scene
            bird.position.set(0, 0, 0);
            scene.add(bird);
            
            // Create collision box
            const birdBoundingBox = new THREE.Box3().setFromObject(bird);
            const birdSize = birdBoundingBox.getSize(new THREE.Vector3());
            
            const boxGeo = new THREE.BoxGeometry(birdSize.x * 0.6, birdSize.y * 0.6, birdSize.z * 0.6);
            const boxMat = new THREE.MeshBasicMaterial({
                wireframe: true,
                visible: false
            });
            
            birdBox = new THREE.Mesh(boxGeo, boxMat);
            bird.add(birdBox);
        }
        
        function createParticleSystem() {
            // Create particle system for trail effect
            const particlesGeo = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            const colors = new Float32Array(particleCount * 3);
            
            const colorOptions = [
                new THREE.Color(0xFFEB3B), // Yellow
                new THREE.Color(0xFFC107), // Amber
                new THREE.Color(0xFF9800), // Orange
                new THREE.Color(0xFFFFFF)  // White
            ];
            
            for (let i = 0; i < particleCount; i++) {
                positions[i * 3] = bird.position.x - (Math.random() * 4 + 2); // Emit further back (x-axis)
                positions[i * 3 + 1] = bird.position.y - (Math.random() * 0.5);
                positions[i * 3 + 2] = bird.position.z + (Math.random() * 0.8 - 0.4); // Narrower spread on z-axis
                
                const randomColor = colorOptions[Math.floor(Math.random() * colorOptions.length)];
                colors[i * 3] = randomColor.r;
                colors[i * 3 + 1] = randomColor.g;
                colors[i * 3 + 2] = randomColor.b;
                
                particles.push({
                    velocity: new THREE.Vector3(
                        -Math.random() * 0.2,
                        Math.random() * 0.1 - 0.05,
                        Math.random() * 0.04 - 0.02 // Narrower velocity spread on z-axis
                    ),
                    alpha: 1.0
                });
            }
            
            particlesGeo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            particlesGeo.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            
            const particleMaterial = new THREE.PointsMaterial({
                size: 0.2,
                vertexColors: true,
                transparent: true,
                opacity: 0.8
            });
            
            particleSystem = new THREE.Points(particlesGeo, particleMaterial);
            scene.add(particleSystem);
        }
        
        function updateParticles() {
            const positions = particleSystem.geometry.attributes.position.array;
            
            for (let i = 0; i < particleCount; i++) {
                // If the particle is too far from the bird, reset it
                if (positions[i * 3] < bird.position.x - 7) {
                    positions[i * 3] = bird.position.x - (Math.random() * 4 + 2); // Reset further back
                    positions[i * 3 + 1] = bird.position.y - (Math.random() * 0.5);
                    positions[i * 3 + 2] = bird.position.z + (Math.random() * 0.8 - 0.4); // Narrower spread
                    particles[i].alpha = 1.0;
                }
                
                // Move particle based on its velocity
                positions[i * 3] += particles[i].velocity.x;
                positions[i * 3 + 1] += particles[i].velocity.y;
                positions[i * 3 + 2] += particles[i].velocity.z;
                
                // Decrease alpha over time
                particles[i].alpha -= 0.02;
                if (particles[i].alpha < 0) particles[i].alpha = 0;
            }
            
            particleSystem.geometry.attributes.position.needsUpdate = true;
            particleSystem.material.opacity = gameStarted ? 0.8 : 0;
        }
        
        function createPipe() {
            const pipe = new THREE.Group();
            
            // Random gap position and height
            const gapHeight = 14; // Even more generous gap
            const gapPosition = Math.random() * 8 - 4; // Reduced variance for more predictable gaps
            
            // Colors for the pipes - green with some variations
            const colors = [0x2E7D32, 0x388E3C, 0x43A047];
            const randomColor = colors[Math.floor(Math.random() * colors.length)];
            
            // Top pipe
            const topHeight = 30 - (gapPosition + gapHeight / 2);
            const topGeo = new THREE.BoxGeometry(3, topHeight, 3);
            const topMat = new THREE.MeshPhongMaterial({
                color: randomColor,
                shininess: 30
            });
            const topPipe = new THREE.Mesh(topGeo, topMat);
            topPipe.position.y = gapPosition + gapHeight / 2 + topHeight / 2;
            topPipe.castShadow = true;
            topPipe.receiveShadow = true;
            
            // Top pipe cap
            const topCapGeo = new THREE.BoxGeometry(4, 1, 4);
            const topCapMat = new THREE.MeshPhongMaterial({
                color: 0x1B5E20,
                shininess: 40
            });
            const topCap = new THREE.Mesh(topCapGeo, topCapMat);
            topCap.position.y = gapPosition + gapHeight / 2;
            topCap.castShadow = true;
            topCap.receiveShadow = true;
            
            // Bottom pipe
            const bottomHeight = 30 - Math.abs(gapPosition - gapHeight / 2);
            const bottomGeo = new THREE.BoxGeometry(3, bottomHeight, 3);
            const bottomMat = new THREE.MeshPhongMaterial({
                color: randomColor,
                shininess: 30
            });
            const bottomPipe = new THREE.Mesh(bottomGeo, bottomMat);
            bottomPipe.position.y = gapPosition - gapHeight / 2 - bottomHeight / 2;
            bottomPipe.castShadow = true;
            bottomPipe.receiveShadow = true;
            
            // Bottom pipe cap
            const bottomCapGeo = new THREE.BoxGeometry(4, 1, 4);
            const bottomCapMat = new THREE.MeshPhongMaterial({
                color: 0x1B5E20,
                shininess: 40
            });
            const bottomCap = new THREE.Mesh(bottomCapGeo, bottomCapMat);
            bottomCap.position.y = gapPosition - gapHeight / 2;
            bottomCap.castShadow = true;
            bottomCap.receiveShadow = true;
            
            // Add to pipe group
            pipe.add(topPipe);
            pipe.add(topCap);
            pipe.add(bottomPipe);
            pipe.add(bottomCap);
            
            // Set initial position
            pipe.position.x = 30;
            pipe.userData = {
                passed: false,
                gapPosition: gapPosition,
                gapHeight: gapHeight,
                questionShown: false // Track if a question has been shown for this pipe
            };
            
            // Add to scene and pipes array
            scene.add(pipe);
            pipes.push(pipe);
        }
        
        function updatePipes() {
            const pipeSpeed = 0.15;
            
            for (let i = 0; i < pipes.length; i++) {
                const pipe = pipes[i];
                pipe.position.x -= pipeSpeed;
                
                // Check if pipe has been passed
                if (!pipe.userData.passed && pipe.position.x < bird.position.x) {
                    pipe.userData.passed = true;
                    score += 10;
                    updateScore();
                    playScoreSound();
                    
                    // Check if we should show a question after passing this pipe
                    if (!questionShowing && !pipe.userData.questionShown && Math.random() < questionChance) {
                        // Small delay to give player time to clear the pipe
                        setTimeout(() => {
                            showQuestion();
                            pipe.userData.questionShown = true;
                        }, 500);
                    }
                }
                
                // Remove pipe if it's off screen
                if (pipe.position.x < -30) {
                    scene.remove(pipe);
                    pipes.splice(i, 1);
                    i--;
                }
            }
            
            // Add new pipes
            const elapsedTime = clock.getElapsedTime();
            if (elapsedTime - lastPipeTime > 2) {
                createPipe();
                lastPipeTime = elapsedTime;
            }
        }
        
        function updateClouds() {
            for (const cloud of clouds) {
                cloud.mesh.position.x -= cloud.speed;
                if (cloud.mesh.position.x < -100) {
                    cloud.mesh.position.x = 100;
                }
            }
        }
        
        function checkCollisions() {
            if (!gameStarted || gameOver || questionShowing) return;
            
            // Check for collision with ground
            if (bird.position.y < -9) {
                endGame();
                return;
            }
            
            // Get bird position for simpler collision detection
            const birdPos = bird.position.clone();
            
            // Check for collision with pipes using distance-based detection
            for (const pipe of pipes) {
                // For each pipe section
                const pipeChildren = pipe.children;
                let collision = false;
                
                // Only check the actual pipe bodies (indices 0 and 2), not the caps
                const pipeTop = pipeChildren[0];
                const pipeBottom = pipeChildren[2];
                
                // Get world positions of pipe sections
                const topPos = new THREE.Vector3();
                pipeTop.getWorldPosition(topPos);
                
                const bottomPos = new THREE.Vector3();
                pipeBottom.getWorldPosition(bottomPos);
                
                // Get pipe dimensions (adjust for scaling and positioning)
                const pipeWidth = 3;
                const pipeDepth = 3;
                
                // Check top pipe collision with a very generous buffer
                if (Math.abs(birdPos.x - topPos.x) < 1.8 && // X-axis proximity (reduced from standard width)
                    Math.abs(birdPos.z - topPos.z) < 1.8 && // Z-axis proximity (reduced from standard depth)
                    birdPos.y > pipe.userData.gapPosition + pipe.userData.gapHeight/2 - 0.8) { // Bird is in top pipe territory with buffer
                    // Only trigger if very close to the pipe body
                    const distanceToTopPipe = Math.sqrt(
                        Math.pow(birdPos.x - topPos.x, 2) + 
                        Math.pow(birdPos.z - topPos.z, 2));
                    
                    if (distanceToTopPipe < 1.5) {
                        collision = true;
                    }
                }
                
                // Check bottom pipe collision with a very generous buffer
                if (Math.abs(birdPos.x - bottomPos.x) < 1.8 && // X-axis proximity
                    Math.abs(birdPos.z - bottomPos.z) < 1.8 && // Z-axis proximity
                    birdPos.y < pipe.userData.gapPosition - pipe.userData.gapHeight/2 + 0.8) { // Bird is in bottom pipe territory with buffer
                    // Only trigger if very close to the pipe body
                    const distanceToBottomPipe = Math.sqrt(
                        Math.pow(birdPos.x - bottomPos.x, 2) + 
                        Math.pow(birdPos.z - bottomPos.z, 2));
                    
                    if (distanceToBottomPipe < 1.5) {
                        collision = true;
                    }
                }
                
                if (collision) {
                    endGame();
                    return;
                }
            }
        }
        
        function showQuestion() {
            if (gameOver) return;
            
            // Pause the game
            questionShowing = true;
            
            // Get random question
            const questionData = questions[Math.floor(Math.random() * questions.length)];
            const questionModal = document.getElementById('question-modal');
            const questionText = document.getElementById('question-text');
            const answersDiv = document.getElementById('answers');
            
            // Set question text
            questionText.textContent = questionData.question;
            
            // Clear previous answers
            answersDiv.innerHTML = '';
            
            // Add answer buttons
            questionData.answers.forEach((answer, index) => {
                const button = document.createElement('button');
                button.className = 'answer-btn';
                button.textContent = answer;
                button.onclick = () => {
                    // Award points for correct answer
                    if (index === questionData.correct) {
                        score += 50;
                        updateScore();
                        
                        // Add visual feedback for correct answer
                        button.style.backgroundColor = '#4CAF50';
                    } else {
                        // Visual feedback for wrong answer
                        button.style.backgroundColor = '#F44336';
                    }
                    
                    // Hide question after short delay to show feedback
                    setTimeout(() => {
                        questionModal.style.display = 'none';
                        questionShowing = false;
                    }, 500);
                };
                answersDiv.appendChild(button);
            });
            
            // Show question modal
            questionModal.style.display = 'block';
        }
        
        function flapBird() {
            if (gameOver || questionShowing) return;
            
            if (!gameStarted) {
                startGame();
                return;
            }
            
            velocity = jump;
            playFlapSound();
            
            // Animation effects
            bird.children[3].rotation.x = -0.5; // Left wing
            bird.children[4].rotation.x = -0.5; // Right wing
            
            // Add flap particles
            addFlapParticles();
        }
        
        function addFlapParticles() {
            const flapsGeo = new THREE.BufferGeometry();
            const positions = new Float32Array(20 * 3);
            const colors = new Float32Array(20 * 3);
            
            for (let i = 0; i < 20; i++) {
                positions[i * 3] = bird.position.x - (Math.random() * 0.5);
                positions[i * 3 + 1] = bird.position.y - (Math.random() * 0.5);
                positions[i * 3 + 2] = bird.position.z + (Math.random() * 2 - 1);
                
                colors[i * 3] = 1.0;
                colors[i * 3 + 1] = 1.0;
                colors[i * 3 + 2] = 1.0;
            }
            
            flapsGeo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            flapsGeo.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            
            const flapsMaterial = new THREE.PointsMaterial({
                size: 0.1,
                color: 0xFFFFFF,
                transparent: true,
                opacity: 0.8
            });
            
            const flaps = new THREE.Points(flapsGeo, flapsMaterial);
            scene.add(flaps);
            
            // Remove after animation
            setTimeout(() => {
                scene.remove(flaps);
            }, 200);
        }
        
        function updateBird() {
            if (!gameStarted || questionShowing) {
                // Idle animation
                bird.position.y = Math.sin(clock.getElapsedTime() * 2) * 0.5;
                bird.rotation.z = Math.sin(clock.getElapsedTime() * 2) * 0.05;
                return;
            }
            
            // Apply gravity
            velocity += gravity * 0.1;
            bird.position.y -= velocity * 0.1;
            
            // Rotate bird based on velocity
            const targetRotation = velocity * 0.05;
            bird.rotation.z = THREE.MathUtils.lerp(bird.rotation.z, targetRotation, 0.1);
            
            // Reset wing rotation
            bird.children[3].rotation.x = THREE.MathUtils.lerp(bird.children[3].rotation.x, 0, 0.1);
            bird.children[4].rotation.x = THREE.MathUtils.lerp(bird.children[4].rotation.x, 0, 0.1);
            
            // Update light to follow bird
            pointLight.position.set(bird.position.x, bird.position.y, bird.position.z);
        }
        
        function startGame() {
            if (gameStarted) return;
            
            gameStarted = true;
            gameOver = false;
            questionShowing = false;
            velocity = 0;
            score = 0;
            updateScore();
            
            // Reset bird position
            bird.position.set(0, 0, 0);
            bird.rotation.z = 0;
            
            // Clear pipes
            for (const pipe of pipes) {
                scene.remove(pipe);
            }
            pipes = [];
            
            // Start pipe generation
            lastPipeTime = clock.getElapsedTime();
            createPipe();
            
            // Hide UI elements
            document.getElementById('start-screen').style.display = 'none';
            document.getElementById('game-over-screen').style.display = 'none';
            document.getElementById('question-modal').style.display = 'none';
            
            playStartSound();
        }
        
        function endGame() {
            if (gameOver) return;
            
            gameOver = true;
            playGameOverSound();
            
            // Show game over screen
            document.getElementById('game-over-screen').style.display = 'flex';
            document.getElementById('final-score').textContent = `Score: ${score}`;
            
            // Make sure question modal is hidden
            document.getElementById('question-modal').style.display = 'none';
        }
        
        function restartGame() {
            startGame();
        }
        
        function updateScore() {
            document.getElementById('score-display').textContent = `Score: ${score}`;
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        // Sound effects (simulated as we can't include actual audio)
        function playFlapSound() {
            // In a real implementation, this would play a sound
            console.log('Flap sound');
        }
        
        function playScoreSound() {
            // In a real implementation, this would play a sound
            console.log('Score sound');
        }
        
        function playGameOverSound() {
            // In a real implementation, this would play a sound
            console.log('Game over sound');
        }
        
        function playStartSound() {
            // In a real implementation, this would play a sound
            console.log('Start sound');
        }
        
        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            
            updateBird();
            
            if (gameStarted && !gameOver && !questionShowing) {
                updatePipes();
                checkCollisions();
            }
            
            updateParticles();
            updateClouds();
            
            // Rotate skybox
            skybox.rotation.y += 0.0001;
            
            renderer.render(scene, camera);
        }
        
        // Initialize the game
        init();
    </script>
</body>
</html>